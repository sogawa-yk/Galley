---
description: フィードバックファイルを読み込み、問題を自動修正する
---

# フィードバック修正 (完全自動実行モード)

**重要:** このワークフローは、ユーザーの介入なしに、開始から完了まで完全に自動で実行されるように設計されています。各ステップは完了後、ただちに次のステップへ移行してください。思考の途中でユーザーに確認を求めたり、作業を中断したりしないでください。

**引数:** フィードバックファイル名 (例: `/fix-feedback 2026-02-19-hearing-session.md`)

フィードバックファイルは `docs/feedbacks/` ディレクトリに配置されたマークダウンファイルです。
Claude Desktop等で実際に操作した結果の問題点・改善要望が記述されています。

---

## ステップ1: フィードバックの読み込みと分析

1. フィードバックファイルを読み込む:
  - パス: `docs/feedbacks/[引数で与えられたファイル名]`
  - ファイルが存在しない場合はエラーメッセージを表示して終了する。
  - ファイル末尾に `## 対応結果` セクションが既に存在する場合は、対応済みである旨をユーザーに通知して終了する。
2. フィードバック内容を分析し、以下を特定する:
  - **問題の種類**: バグ修正、UX改善、プロンプト改善、設定変更、ドキュメント修正、etc.
  - **影響範囲**: どの層（モデル・サービス・ツール・プロンプト・インフラ・設定）に影響するか
  - **修正項目リスト**: 個別の修正タスクに分解する

## ステップ2: 準備とコンテキスト設定

1. 現在のタスクコンテキストを確立する:
  - フィードバックファイル名から簡潔な名前を抽出する（例: `2026-02-19-hearing-session.md` → `hearing-session-feedback`）
  - 日付: `[現在の日付をYYYYMMDD形式で取得]`
  - ステアリングディレクトリパス: `.steering/[日付]-[名前]/`
2. 上記ステアリングディレクトリを作成する。
3. 以下の3つの空ファイルを作成する:
  - `[ステアリングディレクトリパス]/requirements.md`
  - `[ステアリングディレクトリパス]/design.md`
  - `[ステアリングディレクトリパス]/tasklist.md`

## ステップ3: プロジェクト理解

1. `CLAUDE.md`を読み、プロジェクトの全体像を把握する。
2. `docs/`ディレクトリ内の永続ドキュメントを確認し、フィードバックに関連する設計思想やアーキテクチャを理解する。

## ステップ4: 既存コードの調査

1. フィードバックで指摘された問題に関連するソースコード(`src/`)をGrepツールで検索する。
2. 関連するテストコード(`tests/`)も確認する。
3. 問題の根本原因を特定する。

## ステップ5: 計画フェーズ (ステアリングファイルの自動生成)

1. `Skill('steering')`を**計画モード**で実行し、ステップ2で作成した3つのファイルの内容を生成する。
  - `requirements.md`: フィードバック内容を要求仕様として構造化する。元のフィードバックファイルへの参照(`docs/feedbacks/[ファイル名]`)を含める。
  - `design.md`: 修正アプローチを設計する。
  - `tasklist.md`: 修正タスクをリスト化する。
2. **このステップが正常に完了したら、決して停止せず、ただちにステップ6に進むこと。**

## ステップ6: 実装ループ (tasklist.mdの完全消化)

**このステップは、`tasklist.md`の全タスクが `[x]` になるまで自動で繰り返されるループ処理です。**
**このステップが正常に完了したら、決して停止せず、ただちにステップ7に進むこと。**

**ループ開始:**

1. タスクリストの読み込み:
  - `[ステアリングディレクトリパス]/tasklist.md`ファイルを読み込む。

2. 進捗の確認:
  - ファイル内に未完了タスク (`[ ]`) が存在するか確認する。
  - **もし未完了タスクが存在しない場合:** この実装ループは完了とみなし、ただちに**ステップ7**へ進む。
  - **もし未完了タスクが存在する場合:** 次の処理（3. タスクの実行）に進む。

3. タスクの実行:
  - `tasklist.md`の**先頭にある未完了タスク**を1つ特定する。
  - そのタスクを完了させるために必要な修正作業を実行する。
  - `Skill('steering')`を**実装モード**で使用する。
  - `Skill('development-guidelines')`のコーディング規約を常に遵守する。

4. タスクリストの更新:
  - 実行したタスクが完了したら、`Edit`ツールを使用して`tasklist.md`を更新し、該当タスクを `[ ]` から `[x]` に変更する。

5. ループ継続:
  - **ステップ6の先頭 (1. タスクリストの読み込み) に戻り、処理を繰り返す。**

---
### ※ 実装ループ内の例外処理ルール ※

実装ループの実行中に以下の状況が発生した場合は、このルールに従って自律的に対処し、ループを継続すること。

- **ルールA: タスクが大きすぎる場合**
  - **対処法:** 現在のタスクをより小さな複数のサブタスクに分割する。`Edit`ツールを使い、元のタスクを削除し、その場所に新しいサブタスク（`[ ]`付き）を挿入する。その後、ループを継続する。

- **ルールB: 技術的理由でタスクが不要になった場合**
  - **条件:** 実装方針の変更、アーキテクチャの変更、依存関係の変更など、明確な技術的理由がある場合にのみ適用。
  - **対処法:** `Edit`ツールを使い、該当タスクを `[x] ~~タスク名~~ (理由: [具体的な技術的理由を簡潔に記述])` の形式で更新する。その後、ループを継続する。

- **❌ 絶対禁止の行為:**
  - 未完了タスクを「後でやる」「別タスクにする」などの理由で意図的にスキップすること。
  - 理由なく未完了タスクを放置してループを終了させること。
  - ユーザーに判断を仰ぐこと。

---

## ステップ7: 実装検証 (サブエージェント起動)

1. `tasklist.md`の全タスクが完了したことを最終確認する。
2. `Task`ツールを使用し、`implementation-validator`サブエージェントを起動して品質を検証する。
  - `subagent_type`: "implementation-validator"
  - `description`: "Implementation quality validation"
  - `prompt`: "フィードバック `[フィードバックファイル名]` に基づく修正の品質を検証してください。対象ファイルは `[修正したファイルのパスリスト]` です。コーディング規約、エラーハンドリング、テスト可能性、既存パターンとの整合性を重点的に確認してください。また、フィードバックで指摘された問題が適切に修正されているかを検証してください。"

**このステップが正常に完了したら、決して停止せず、ただちにステップ8に進むこと。**

## ステップ8: 自動テストの実行

1. 以下のコマンドを順番に実行し、全てのテストがパスすることを確認する。
  ```bash
  uv run pytest
  uv run ruff check src/ tests/
  uv run ruff format --check src/ tests/
  uv run mypy src/
  ```
2. いずれかのコマンドでエラーが発生した場合は、問題を分析し、修正コードを生成・適用してから、再度このステップを実行する。

**このステップが正常に完了したら、決して停止せず、ただちにステップ8.5に進むこと。**

## ステップ8.5: E2Eスモークテスト (mcp-gauge)

**前提条件チェック:** このステップは、ステップ6の実装で以下のいずれかのファイルを変更した場合のみ実行する。いずれも変更していない場合は「スキップ（IaC非関連の修正）」としてステップ9へ進む。

対象ファイルパターン:
- `src/galley/services/design.py`
- `src/galley/services/infra.py`
- `src/galley/validators/architecture.py`
- `config/oci-services.yaml`
- `src/galley/tools/design.py`, `src/galley/tools/infra.py`, `src/galley/tools/export.py`
- `src/galley/prompts/design.py`, `src/galley/prompts/infra.py`

**環境情報:** `docs/environment.md` からコンパートメントOCID・リージョンを取得する。取得できない場合はデフォルト値を使用する（`tests/e2e/conftest.py` 参照: compartment=`ocid1.compartment.oc1..aaaaaaaanxm4oucgt5pkgd7sw2vouvckvvxan7ca2lirowaao7krnzlkdkhq`, region=`ap-osaka-1`）。

**テストフロー:**

1. Galleyサーバーを起動する:
   ```bash
   GALLEY_WORK_COMPARTMENT_ID=[コンパートメントOCID] GALLEY_REGION=[リージョン] uv run galley --port 19876 &
   GALLEY_PID=$!
   sleep 3
   ```

2. mcp-gaugeで接続する:
   - `gauge_connect(server_url="http://localhost:19876/mcp")`

3. VCNスモークテストを順次実行する（`tests/e2e/test_terraform_plan.py` のパターンを参照）:
   - `gauge_proxy_call`: `create_session` → `galley_session_id` を取得
   - `gauge_proxy_call`: `save_answers_batch` で最小限の回答を送信（purpose: "E2Eスモークテスト", scale: "small", availability: "standard", budget: "minimal"）
   - `gauge_proxy_call`: `complete_hearing`
   - `gauge_proxy_call`: `save_architecture` でVCN 1個の最小構成を保存（components: `[{"service_type": "vcn", "display_name": "Smoke Test VCN", "config": {"cidr_block": "10.254.0.0/16"}}]`, connections: `[]`）
   - `gauge_proxy_call`: `validate_architecture`
   - `gauge_proxy_call`: `export_iac` → `terraform_dir` を取得
   - `gauge_proxy_call`: `run_terraform_plan` で plan-only 実行（variables: `{"compartment_id": "[コンパートメントOCID]", "region": "[リージョン]"}`）

4. mcp-gaugeの後処理:
   - `gauge_disconnect`
   - `gauge_evaluate`

5. サーバーを停止する:
   ```bash
   kill $GALLEY_PID
   ```

**結果判定:**
- **全成功（PASSEDと判定）**: Terraform planが成功し、"to add"を含むplan summaryが得られた → ステップ9へ進む
- **IaCバグによる失敗（FAILEDと判定）**: Terraform planがエラー（構文エラー、参照エラー、無効なパラメータ等）→ ステップ8.6へ進む
- **環境依存エラー（スキップと判定）**: サーバー起動失敗、mcp-gauge接続タイムアウト、OCI認証エラー、クォータ超過等 → 「スキップ（環境依存エラー: [エラー内容]）」としてステップ9へ進む

## ステップ8.6: E2Eテスト失敗時のフィードバック生成

**このステップはステップ8.5でFAILEDと判定された場合のみ実行する。**

1. `docs/feedbacks/[日付]-e2e-regression.md` を作成する。フォーマット:
   ```markdown
   # E2Eリグレッション検出レポート

   **検出日**: [日付]
   **元フィードバック**: `docs/feedbacks/[元のフィードバックファイル名]`
   **テストツール**: mcp-gauge (VCN plan-onlyスモークテスト)

   ---

   ## 問題詳細

   ### [エラーの簡潔な説明]

   **症状**: [Terraform planのエラーメッセージ]

   **原因分析**: [根本原因の推定]

   **gaugeトレース**: [gauge_evaluateの結果から関連部分を抜粋]

   ---

   ## 改善提案

   1. [具体的な修正案]
   ```

2. ユーザーに通知する: 「E2Eスモークテストで新規バグを検出しました。`docs/feedbacks/[日付]-e2e-regression.md` を作成しました。次回の `/fix-feedback` で対応可能です。」

3. **ブロッカーにせず、ステップ9へ進む。**

## ステップ9: 振り返りとドキュメント更新

1. `Skill('steering')`を**振り返りモード**で実行し、`tasklist.md`に申し送り事項を記載する。
  - 実装完了日
  - 計画と実績の差分
  - 学んだこと
  - 次回への改善提案

2. 今回の変更がプロジェクトの基本設計やアーキテクチャに影響を与えるか判断する。

3. 影響がある場合、`docs/`内の関連する永続ドキュメントを`Edit`ツールで更新する。

4. フィードバックファイルの末尾に対応結果を追記する:
  ```markdown
  ---
  ## 対応結果
  - **対応日**: [日付]
  - **ステアリング**: `.steering/[ステアリングディレクトリ名]/`
  - **対応内容の要約**: [修正内容の簡潔な要約]
  - **E2Eスモークテスト**: [PASSED / FAILED（新規フィードバック作成済み） / スキップ（理由）]
  ```

## 完了条件

このワークフローは、以下の全ての条件を満たした時点で自動的に完了となる。
- ステップ6: `tasklist.md`の全てのタスクが完了状態（`[x]`または正当な理由でスキップ）になっている。
- ステップ7: `implementation-validator`サブエージェントの検証をパスする。
- ステップ8: `pytest`, `ruff check`, `ruff format`, `mypy`の全てのコマンドがエラーなく成功する。
- ステップ8.5: PASSEDまたはスキップ（正当な理由あり）。
- ステップ8.6:（失敗時のみ）新規フィードバックファイル `docs/feedbacks/[日付]-e2e-regression.md` が作成されている。
- ステップ9: `tasklist.md`に申し送り事項が記載されている。フィードバックファイルに対応結果が追記されている。

この完了条件を満たすまで、自律的に思考し、問題解決を行い、作業を継続すること。
